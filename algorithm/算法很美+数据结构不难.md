## 一 位运算

### 1.1 位运算与进制基础

### 1.2 题解



### 二 查找与排序

### 2.1 递归、查找与排序补充

#### 递归

- **递归设计经验**
  - 找重复（子问题）
    - 直接量+小规模子问题
    - 多个小规模子问题
  - 找重复中的变化量-->参数
  - 找参数变化趋势-->设计出口
- **练习策略**
  - 循环改递归
  - 经典递归
  - 大量练习,总结规律,掌握套路
  - 找到感觉,挑战高难度
- **递归基础练习**
  - 求阶乘
  - 打印i-j
  - 数组求和
  - 翻转字符串
  - 斐波那契数列
  - 最大公约数
  - 插入排序改递归
  - 汉诺塔



#### 二分查找递归解法

```java
private static int binarySearch1(int[] arr,int low,int high,int key){
    if(low>high)
        return -1;
    int mid=low+((high-low)>>1);//(low+high)>>>1;//
    int midVal=arr[mid];
    if(midVal<key)
        return binarySearch1(arr,mid+1,high,key);
    else if(midVal>key)
        return binarySearch1(arr,low,high-1,key);
    else
        return mid;//key found
}
```



#### 希尔排序

一趟一增量,用增量分组,组内排序

```java
private static void shellSort(int[] arr){
    //不断地缩小增量
    for(int interval=arr.length/2;interval>0;interval=interval/2){
        //增量为1的插入排序
        for(int i=interval;i<arr.length;i++){
            int target=arr[i];
            int j=i-interval;
            while(j>-1&&target<arr[j]){
                arr[j+interval]=arr[j];
                j-=interval;
            }
            arr[j+interval]=target;
        }
    }
}
```





### 2.2 如何评价算法性能

#### 大O表示法

#### 常见算法复杂度

| 算法复杂度n | 1s可处理的规模 |
| ----------- | -------------- |
| lgn         | 2^(100000000)  |
| n           | 100000000      |
| n^2         | 10000          |
| n^3         | 500            |
| 2^n         | 27             |

顺序查找:O(n)

二分查找:O(lgn)

冒泡\插入\选择排序:O(n)

Arrays.sort()/快速排序:O(nlgn)



#### **2的幂表**

| 2的幂 | 准确值(X)     | 近似值           | X字节转换成MB\GB等 |
| ----- | ------------- | ---------------- | ------------------ |
| 7     | 128           |                  |                    |
| 8     | 256           |                  |                    |
| 10    | 1024          | 一千             | 1K                 |
| 16    | 65536         |                  | 64K                |
| 20    | 1048576       | 一百万           | 1MB                |
| 30    | 1073741824    | 十亿             | 1GB                |
| 32    | 4294967296    |                  | 4GB                |
| 40    | 1099511627776 | 一万亿(trillion) | 1TB                |



#### 递归算法性能分析

**考量:**

1.子问题的规模下降

2.子问题的答案的处理消耗时间

写出:T(n)=T(n-1)+O(1)

**典例**:

- **汉诺塔递归算法分析**

  T(n)=2T(n-1)+O(1)=O(2^n)

- **斐波那契数列递归形式的算法分析**

   T(n)=T(n-1)+T(n-2)+O(1)=2(T(n-1))=O(2^n)----由分支而定

- **最大公约数算法分析**

  T(n)=T(n/2)+O(1)=O(logn)

  | 递归关系                | 结果            | 举例                 |
  | ----------------------- | --------------- | -------------------- |
  | T(n)=T(n/2)+O(1)        | T(n)=O(logn)    | 二分查找,欧几里得GCD |
  | T(n)=T(n-1)+O(1)        | T(n)=O(n)       | 线性查找             |
  | T(n)=2T(n/2)+O(1)       | T(n)=O(n)       |                      |
  | T(n)=2T(n/2)+O(n)       | T(n)=O(nlogn)   | 归并,快排            |
  | T(n)=2T(n/2)+O(nlogn)   | T(n)=O(nlog^2n) |                      |
  | T(n)=T(n-1)+O(n)        | T(n)=O(2^n)     | 选择排序,插入排序    |
  | T(n)=2T(n-1)+O(1)       | T(n)=O(2^n)     | 汉诺塔               |
  | T(n)=T(n-1)+T(n-2)+O(1) | T(n)=O(2^n)     | 递归的斐波那契       |

- **希尔排序的性能分析**

  - 无序时,元素少
  - 元素多时.已基本有序
  - nlgn~n^2----n^1.3



#### 排序算法的稳定性



### 2.3 典例详解

- 小白上楼梯
- 旋转数组的最小数组(改造二分法)
- 在有空字符串的有序字符串数组中查找
- 最长连续递增子序列(部分有序)
- 设计一个高效的求a的n次幂的算法



### 2.4 分治思想：快速排序、归并排序

#### 分治法（divide and conquer，D&C）

- 将原问题划分成若干个规模较小而结构与原问题一致的子问题；递归地解决这些子问题然后再合并其结果，就得到原问题的解。
- 容易确定运行时间，是分治算法的优点之一
- 分支模式在每一层递归上都有三个步骤：
  - **分解（Divide）**：将原问题分解成一系列子问题
  - **解决（Conquer）**：递归地解决各子问题。若子问题足够小，则直接有解
  - **合并（Combine）**：将子问题的结果合并成原问题的解



#### 快速排序

- 算法

  - 分解：左小右大
  - 解决：通过递归调用快速排序
  - 合并：子数值都是原址排序的，故不需合并，数组已有序

- 关键--划分

- **单向扫描分区**

  - 思路：用两个指针将数组划分为三个区间

  - 扫描指针（scan_pos）左边是确认小于等于主元的

  - 扫描指针到未知区间末指针（next_bigger_pos）中间未知，末指针的右边区间为确认大于主元的元素

  - ```java
    public static void quickSort(int[] A,int p,int r){
        if(p<r){
            int q=partition(A,p,r);
            quickSort(A,p,q-1);
            quickSort(A,q+1,r);
        }
    }
    
    public static int partition(int[] A,int p,int r){
        int pivot=A[p];
        int sp=p+1;
        int bigger=r;
        while(sp<=bigger){
            if(A[sp]<=pivot)
                sp++;
            else{
                int temp=A[bigger];
                A[bigger]=A[sp];
                A[sp]=A[bigger];
                bigger--;
            }
        }
        int temp=A[bigger];
        A[bigger]=A[p];
        A[p]=temp;
        return bigger;
    }
    ```

- **双向扫描分区**

  - ```java
    public static void quickSort(int[] A,int p,int r){
        if(p<r){
            int q=partition(A,p,r);
            quickSort(A,p,q-1);
            quickSort(A,q+1,r);
        }
    }
    
    public static int partition(int[] A,int p,int r){
        int pivot=A[p];
        int left=p+1;
        int right=r;
        while(left<=right){
            while(left<=right&&A[left]<=pivot)left++;
            while(left<=right&&A[right]>pivot)right--;
            if(left<right){
                int temp=A[right];
                A[right]=A[left];
                A[left]=temp;
            }
        }
        int temp=A[right];
        A[right]=A[p];
        A[p]=temp;
        return right;
    }
    ```

- **三指针分区**

  - ```java
    public static void quickSort(int[] A,int p,int r){
        if(p<r){
            int q1=partition(A,p,r)[1];
            int q2=partition(A,p,r)[2];
            qucikSort(A,p,q1-1);
            qucikSort(A,q2+1,r);
        }
    }
    
    public static int[] partition(int[] A,int p,int r){
        int pivot=A[p];
        int left=p+1;
        int equal=p+1;
        int right=r;
        while(left<=right){
            while(left<=right&&A[left]<pivot){
                left++;
                equal++;
            }
    		if(A[left]==pivot){
                left++;
            }
            if(A[left]>pivot){
                
            }
        }
    }
    ```

- 快排在工程实践中的优化

  - **三点中值法**
  - **绝对中值法**
  - 待排序列表较短时，用**插入排序**



#### 归并排序（Merge Sort）

- 完全依照了**分治思想**

  - **分解**：将n个元素分成各含n/2个元素的子序列
  - **解决**：对两个子序列递归地排序
  - **合并**：合并两个已排序的子序列以得到排序结果

- 和快排不同的是

  - 归并的分解较为随意
  - 重点是合并

- ```java
  public static void MergeSort(int[] arr,int low,int high){
      if(low<high){
          int middle=low+((high-low)>>1);
          MergeSort(arr,low,middle);
          MergeSort(arr,middle+1;high);
          Merge(arr,low,middle,high);
      }
  }
  
  int[] helper=[arr.length];
  
  public static void Merge(int[] arr,int p,int mid,int r){
      copy(arr,p,helper,p,r-p+1);
      int left=p;
      int right=mid+1;
      int current=p;
      
      while(left<=mid&&right<=r){
          if(helper[left]<=helper[right]){
              arr[current]=helper[left];
              current++;
              left++;
          }else{
              arr[current]=helper[right];
              current++;
              right++;
          }
      }
  	while(left<=mid){
          arr[current]=helper[left];
          current++;
          left++;
      }
      while(right<=r){
           arr[current]=helper[right];
           current++;
           right++;
      }
  }
  ```



#### 题解

- 调整数组顺序使奇数位于偶数前面
- 第k小的数
- 超过一半的数字--寻找发帖水王
- 最小可用ID

### 2.5 小和、逆序对等问题求解

- 合并有序数组
- 逆序对个数

### 2.6 空间结构之法：堆排序、计数排序等

#### 树、二叉树简介

可用数组来表示一棵树

#### 堆的概念

- 二叉堆是完全二叉树或者是近似完全二叉树
- 二叉堆满足两个特性
  - 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值
  - 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）
- 任意节点的值都大于其子节点的值---大顶堆
- 任意节点的值都小于其子结点的值---小顶堆

#### 堆排序

1. 堆化，反向调整使得每个子树都是大顶堆或者小顶堆
2. 按需输出元素：把堆顶和最末元素对调，然后调整堆顶元素
3. 时间复杂度：建堆（NlgN）+排序（NlgN）



#### 计数排序

- 用辅助数组对数组中出现的数字计数，元素转下标，下标转元素
- 假设元素均大于等于0，依次扫描原数组，将元素值k记录在辅助数组的k位上
- 依次扫描辅助数组，如果为1，将其插入目标数组的空白处
- 问题
  - 重复元素
  - 有负数

#### 桶排序

- 通过”分配“和”收集“过程来实现排序
- 设计k个桶（bucket）（编号0~k-1），然后将n个输入树分布到各个桶中去，对各个桶中的数进行排序，然后按次序把各个桶中的元素列出来即可
- 时间复杂度 O（n）~O（nlgn）--O（N+N（lgN-lgM））
- 适用于均匀分配

- ```java
  public static void BucketSort(int[] arr){
      int length=arr.length;
      LinkedNode[] bucket=new LinKedNode[length];
      int max=maxOf(arr);
      
      for(int i=0;i<length;i++){
          int value=arr[i];
          int hash=hash(arr[i],max,length);
          if(bucket[hash]==null)
              bucket[hash]=new LinkedNode[value];
          else
              InsertSort(value,bucket[hash],bucket,hash);
      }
      
      int k=0;
      for(LinkedNode node:bucket){
          if(node!=null){
              while(node!=null){
                  arr[k++]=node.value;
                  node=node.next;
              }
          }
      }
  }
  ```



#### 基数排序

-  分配+收集

- 按低位有效数字进行排序，然后逐一向上一位进行排序，直至最高位排序结束

- 约定：待排数字中没有0，没有负数（有负数，做一次转换全部变为正数即可）

- 时间复杂度：O（KN）

- ```java
  public class RadixSort{
      private static ArrayList[] bucket=new ArrayList[10];
      
      static{
          for(int i=0;i<bucket.length;i++){
              bucket[i]=new ArrayList();
          }
      }
      
      private static void sort(int[] arr,int d){
          for(int i=0;i<arr.length;i++){
              putInBucket(arr[i],Util.getDigitOn(arr[i],d));
          }
          int k=0;
          for(int j=0;j<bucket.length;j++){
              for(Object m:bucket[j]){
                  arr[k++]=(Integer)m;
              }
          }
          
          clearAll();
      }
      
      private static void putInBucket(int data,int digitOn){
          switch(digitOn){
              case 0:
                  bucket[0].add(data);
                  break;
              case 1:
                  bucket[1].add(data);
                  break;
              case 2:
                  bucket[2].add(data);
                  break;
              case 3:
                  bucket[3].add(data);
                  break;
              case 4:
                  bucket[4].add(data);
                  break;
              case 5:
                  bucket[5].add(data);
                  break;
              case 6:
                  bucket[6].add(data);
                  break;
              case 7:
                  bucket[7].add(data);
                  break;
              case 8:
                  bucket[8].add(data);
                  break;
              case 9:
                  bucket[9].add(data);
                  break;                 
          }
      }
      
      private static void clearAll(){
          for(ArrayList b:bucket){
              b.clear();
          }
      }
      
      public static void sort(int[] arr){
          int d=1;
          int max=Util.maxOf(arr);
          
          int dNum=1;//最大数据的位数
          while(man/10!=0){
              dNum++;
              max/=10;
          }
          while(d<dNum){
              //依据第二个参数入桶和出桶
              sort(arr,d++);
          }
      }
  }
  ```

  

### 2.7 排序算法小结

- **冒泡排序**--效率低、掌握swap
- **选择排序**--效率较低，但经常用它内部的循环方式来找最大值和最小值--怎么一次性求出数组的最大值和最小值
- **插入排序**--平时效率低，但在序列基本有序时很快，即适用于序列基本有序的情况；Arrays这个工具类在1.7里做了较大改动
- **希尔**（缩小增量排序），是插排的改良，对空间思维训练有帮助

-----------------------------------------------------------————————————————----------------------------

- **快速排序**--软件工业中最常见的常规排序法，其“双向指针扫描”和“分区”算法是核心，往往用于解决类似问题，特别是partition算法用来划分不同性质的元素，partition->selectK，也用于著名的topK问题；重视子问题拆分；若主元不是中位数，尤其当每次主元都在数组一侧时，性能大大下降；工业优化：三点去中法，绝对中值法，小数据量用插入排序
- **归并排序**--重视子问题的解的合并；空间换时间--逆序对数

——————————————————————————————-——————————————-

- **堆排序**--用到了二叉堆数据结构，是继续掌握树结构的起手式=插排+二分查找
- 计数排序--最快：O（N+k），k=maxOf（sourceArr），用它来解决问题时必须注意如果序列中的值分布非常广（最大值很大，元素分布很稀疏），空间将会浪费很多，适用范围：“序列的关键字比较集中，已知边界且边界较小”
- **桶排序**：先分桶，再用其他排序方法对桶内元素排序，按桶的编号依次检出。（分配+收集）适宜于序列的值均匀分布在桶中的情况；若不均匀，那么个别桶中元素会远多于其他桶，桶内排序用比较排序，极端情况下会退化成NlgN；时间复杂度：O（N+C），其中C=N*（logN-logM），约等于N * lgN，N是元素个数，M是桶的个数
- **基数排序**：kN级别（k是最大数的位数）是整数数值型排序里又快又稳的，无论元素分布如何，只需开辟固定的辅助空间（10个桶）；相较桶排序，基数排序每次需要的桶的数量并不多，而且基数排序几乎不需要任何”比较“操作，而桶排序时桶内多个数据必须进行基于比较操作的排序。因而在实际应用中，对于十进制整数而言，基数排序更好用。

——————————————————————————————————————————--------

![image-20200926094022008](C:\Users\帅九妹\AppData\Roaming\Typora\typora-user-images\image-20200926094022008.png)

### 2.8 题解

- 排序数组中找和的因子--二元组、三元组
- 需要排序的子数组
- 前k个数（topK）--小顶堆--*partition和堆都能解决顺序统计量问题，堆更适合海量数据流*
- 所有员工年龄排序
- 数组能排成的最小数（特殊排序）
- 字符串（数组）的包含







## 五 字符串问题

### 5.1 字符串之形

#### 例题

- 串内无重复字符
- 翻转字符串
- 变形词
- 替换空格
- 简单压缩
- 两串的字符集相同
- 旋转词
- 翻转单词
- 去掉连续出现k次的0
- 回文串
- 最短摘要的生成

### 5.2 字符串匹配

#### 字符串匹配之RabinKarp

滚动hash--由O（m*n）改进为O（m+n）



#### 字符串匹配之KMP

如果pj==pk，next（j+1）=k+1或者k<0，next（j+1）=k+1；j++，k++

否则，k继续回溯，直到满足pj==pk或者k<0



#### 字符串匹配之后缀数组

- **什么是后缀数组**
  - 就是串的所有后缀字串的按字典序排序后，在数组中记录后缀的起始下标
  - 后缀数组就是：排名和原下标的映射，sa[0]=5，起始下标为5的后缀在所有后缀中字典序最小
  - rank数组：给定后缀的下标，返回其字典序，rk[5]=0;rk[sa[i]]=i；
- **后缀数组的作用**
  - 匹配--任意子串一定是某后缀串的前缀
- **怎么求后缀数组**
  - 所有后缀放入数组，做Arrays.sort();



## 七 深入递归--深搜、回溯、剪枝等

### 7.1 双管齐下解递归

#### “逐步生成结果”类问题之数值型

- **自下而上的递归（递推，数学归纳，动态规划）**
  - 解决简单情况下的问题
  - 推广到稍复杂情况下的问题
  - ……
  - 如果递推次数很明确，用迭代
  - 如果有封闭形式，可直接求解
- **例子**
  - 上楼梯
  - 机器人走方格
  - 硬币表示
- **为什么写成递归**
  - 因为递归有更强的表达力



#### “逐步生成结果”类问题之非数值型

- **此时需用容器去装**
  - 生成一点，装一点，所谓迭代就是慢慢改变
- **例子**
  - 合法括号
  - 非空子集（集合+二进制法）
  - 字符串（集合）全排列（集合+回溯+前缀法）
- **为什么写成递归**
  - 因为递归有更强的表达力



## 八 贪心策略与动态规划

### 8.1 贪心策略

- 动态规划和贪心算法都是一种递推算法
- 均用局部最优解来推导全局最优解
- 是对遍历解空间的一种优化
- 当问题具有最优子结构时，可用动规，而贪心时动规的一种特列

#### 什么时贪心策略

- **顾眼前**
  - 遵循某种规则，不断（贪心地）选取当前最优策略，最终找到最优解
  - 难点：当前最优未必是整体最优
- **例子**
  - 硬币问题
  - POJ-1700（快速渡河问题）
  - 区间问题及相关问题（区间调度，区间选点POJ1201，1328，区间覆盖问题POJ2376）（另：树状和、前缀和--树状数组）
  - 字典序最小问题（POJ3617）
  - 背包问题及相关问题（最优装载问题，部分背包问题，乘船问题）
- **小结**
  - 最优子结构：对比dfs，不是进行各种可选之路的试探，而是当下就可用某种策略确定选择，无需考虑未来（未来情况的演变也影响不了当下的选择）
  - 只要一直这么选下去，就能得出最终的解，每一步都是当下（子问题）的最优解，结果是原问题的最优解，这叫做最优子结构。
  - 更书面的说法：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。
  - 具备这类结构的问题，可以用局部最优解来推导全局最优解，可以认为是一种剪枝法，是对“dfs遍历法”的优化
  - 贪心：由上一步的最优解推导下一步的最优解，而上一步之前的（历史）最优解则不作保留。



### 8.2 动态规划

#### 什么是动态规划

- 动态规划方法代表了这一类问题（最优子结构or子问题最优性）的一般解法，是设计方法或策略，不是具体算法
- 本质是**递推**，核心是找到**状态转移**的方式，写出**dp方程**
- **形式：**
  - 记忆性递归
  - 递推
- **举例：**
  - 01背包问题
  - 钢条切割问题
  - 数字三角形问题（滚动数组）
  - 最长公共子序列问题
  - 完全背包问题
  - 最长上升子序列问题



#### 小结

- **动态规划用于解决多阶段决策最优化问题**
- **三要素**
  - 阶段
  - 状态
  - 决策
- **两个条件**
  - 最优子结构（最优化原理）
  - 无后效性：当前状态是前面状态的完美总结
- **动规解题的一般思路**
  - **是否可以用动态规划，否则用搜索**
    - 模型匹配：多做题，掌握经典模型
      - 一维：上升子序列模型，背包模型
      - 二维：最长公共子序列问题
    - 寻找规律：规模由小到大，或者由大到小，做逐步分析
    - 放宽条件或增加条件
  - **一般过程**
    - 找到过程演变中变化的量（状态），以及变化的规律（状态转移方程）
    - 确定一些初始状态，通常需要dp数组来保存
    - 利用状态转移方程，推出最终答案
  - **解法**
    - 自顶向下，递归：如果有重叠子问题，带备忘录
    - 自底向上，递推
- **贪心和动规**
  - 可以用局部最优解来推导全局最优解，即动态规划
  - 贪心：这一阶段的解，由上一阶段直接推导出
  - 动规：当前问题的最优解，不能从上一阶段子问题简单得出，需要前面多阶段多层子问题共同计算出，因此需要保留历史上求解过的子问题及其最优解

## 九 线性结构

### 9.1 面向对象要点、数据结构要点

#### 类和对象

- 对象将数据和操作打包在一起，类描述了这一切
- 用构造器创建（实例化）对象
- 类和类之间的关系
  - 关联（组合、聚集）
  - 泛化



#### 关于继承

- **祖先类Object**
- **方法重写**
- **toString方法**
  - 重写toString很常见
- **equals方法**
  - 有时按需会重写equals



#### 关于接口

- **接口概述**
- **Comparable接口**
- **Comparator接口**
- **Cloneable接口**
- **Serializable接口**



#### 数据结构基本概念

- 数据（data）
  - 一切可以输入计算机并能被处理的都是数据
- 数据元素（data element）
- 数据对象（data object）



#### 数据结构（data structure）

- **逻辑结构**
  - 集合：元素罗列在一起
  - 线性结构：元素前后相继（一一对应）
  - 树形结构：元素存在一对多的关系
  - 图结构或网状结构：元素之间存在多对多关系
- **存储结构**
  - 顺序存储：地址连续，用数组
  - 链式存储：地址不连续，用指针（引用，面向对象）



#### 数据结构的主要运算（操作）

1. 建立（Create）一个数据结构
2. 消除（Destroy）一个数据结构
3. 从一个数据结构中删除（Delete）一个数据结构
4. 把一个数据元素插入（Insert）到一个数据结构中
5. 对一个数据结构进行访问（Access）
6. 对一个数据结构（中的数据元素）进行修改（Modify）
7. 对一个数据机构进行排序（Sort）
8. 对一个数据结构进行查找（Search）

### 9.2 基于顺序存储和链式存储的列表

- 定义列表接口
- 用数组实现列表-MyArrayList
- 实现链表（单链表、双链表）
- 迭代器
- 泛型
- Java List API
- 相关技巧

#### 例题

- 桶排序
- 重复结点的移除
- 倒数第k个结点
- 删除单向链表中的某节点

### 9.3 栈

- 栈（stack）又称堆栈，是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除等操作。
- 表中进行插入、删除操作的一端称为栈顶（top），栈顶保存的元素称为栈顶元素。相对的，表的另一端称为栈底（bottom）。
- 当栈中没有数据元素时称为空栈；向一个栈插入元素又称为进栈或入栈；从一个栈中删除元素又称为出栈或退栈。
- 由于栈的插入和删除操作仅在栈顶进行，后进栈的元素必定先出栈。所以又把堆栈称为后进先出表（Last In First Out，简称LIFO）
- 是
- s
- 9.45

### 9.4 队列

- 队列（queue），同堆栈一样，时一种运算首先的线性表，其限制是仅允许在表的一端插入，而在表的另一端进行删除。在队列中把插入数据元素的一端称为队尾，删除数据元素的一端称为队首
- 向队尾插入元素称为进队或入队，新元素入队后成为新的队尾元素；从队列中删除元素称为离队或出队，元素出队后，其后续元素成为新的队首元素
- 队列也称为先进先出表（First In First Out，简称FIFO）
- 2.19

### 9.5 题解

- 设计可查找最小元素的栈
- SetOfStack
- 两个栈实现队列
- 栈的排序
- 猫狗收容所



## 十 哈希

### 10.1 HashMap，HashSet

- **基本概念**
  - 关键字为k，f（k）为散列函数，建立的表为散列表
  - k1！=k2而f（k1）=f（k2）--冲突；需要解决哈希冲突
- **两个关键**
  - **散列函数**
    - 直接定址法
    - 数字分析法
    - 平方取中法
    - 折叠法
    - 随机数法
    - **除留余数法**
  - 冲突解决
    - 开放定址法
    - **拉链法**
    - 双散列
    - 再散列
- 实现HashMap、HashSet



未来待补充：阅读hash相关的源码（优化）

### 10.2 布隆过滤器

- 基本概念
  - 一个很长的二进制向量和一系列随机映射函数；可用于检索一个元素是否在一个集合中。优点是其空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难
- 基本思想
  - 当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，只需看这些点是不是都是1就（大约）知道集合中有没有它：若这些点由任何一个0，则被检元素一定不在，若都是1，则被检元素很可能在。

### 10.3 一致性hash

- **缓存集群/负载均衡**
- **基本思路**
  - 先构造一个长度为2^32的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0,2^32-1])将缓存服务器节点放置在这个Hash环上，然后根据需要缓存的数据的Key值计算得到其Hash值（其分布也为[0,2^32-1]），然后在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找
- **增加/删除结点**
  - 如果往集群中添加一个新的结点NODE4，通过对应的哈希算法得到KEY4，并映射到环中
  - 按顺时针迁移的规则，那么被分割的对象被迁移到了NODE4中，其它对象还保持着原有的存储位置
- **数据倾斜**
  - 如果机器较少，很可能造成机器在整个环上的分布不均匀，从而导致机器之间的负载不均衡
- 虚拟节点

### 10.4 题解

- 大文件中找到出现次数最多的key
- 某海量范围内没有出现的数字
- 海量数据找重复

